新增算法总结:

目的：

新增算法的目的是为了解决下面的问题: 
1: 存在一些left 和 right 的extend 没有值
2: 左右粘合的时候出现的以下问题
   (1) 左右粘合的时候接口处的序列值不准确
   (2) 合并之后左右有一边少了几个碱基
   (3) 粘合之后中间的几个碱基的值跟标准值有出入

算法设计如下: 
1: 解决extend没有值的问题: 
   将参与extend的序列的约束条件放宽: 
    *去掉 //if((*itrSCReads)->bRevsStrand)//我们在这个地方应该允许所有的符合条件的soft clip reads都进来，然后在最后再去定夺是否需要reverse complementary
            //    continue;

     使得可能的seq都被考虑进来


2:  新增算法：
	左右外延的seq存在相应的包含关系的话，那我们需要截断掉边界的seq，保证结果的准确性
        //1：首先选取较长的，然后看较长的是否包含较短的, 防止较长的不正确的延伸

3： 新增一个新的算法：
         * 1：根据左右extend的结果，取得原本序列中能尾部/首部重复的相应的长序列
         * 2：结合这种有特征的长序列，跟左右extend的结果综合考虑得到最终的结果
         * 3：这样的好处在于：比如说左延的序列其右端序列刚好跟右延的序列能够完全匹配，这样可以在很大程度上充分说明这个序列是非常的接近缺失序列的

4： 对于在第三步中找到的相应的包含左右extend seq的原始的 Softclip序列，进行如下操作
    (1) 分成两组，一组是属于包含left extend， 另一组包含right extend，然后分开进行考虑
    (2) 对于属于left extend 的组：
        1: 我们只选择包含left or right extend 的左边的部分呢
        2：将左边的原始的extend序列加入整体考虑的容器之中
           *前提是能在refined的序列组中找个一个序列，使得其作local alignment之后比对上了序列的end部分刚好是left extend的尾部
	3： 右对齐通过1，2步收集到的序列             
        4： 通过词频的统计进行相应的延伸
        5: 这里非常重要，因为rightextend的部分很有可能会贡献left extend 再往左延伸的部分 (也就是超出了标准left extend seq 左边起始点的范围)，因此
	   我们需要通过考虑这种特殊的过长的right extend的 seq去完善 left extend 左边的 flank。因此我们在此需要再走一遍上面的逻辑如下
           (1) 通过寻找right extend中的特殊考虑的whole  soft clip的seq 与 标准的left extend 序列 得到截断序列的左边的部分
           (2) 将这些部分进行相应的词频统计，以及右对齐的处理
           (3) 实际上这种情况发生的很大可能性是在于，左右的extend有很大重复，因此从右边延伸序列截取的左边部分，很有可能比从左边延伸序列截取的左边部分还要长，这也正是这个case需要考虑的根本的原因。
        6: 将从5，6步中得到的结果进行综合考虑
           (1) 首先如果4，5得到的结果有重合，那么我们通过词频，找到出现次数最大的那个
           (2) 如果第5得到的结果比4的结果还要往左进行延伸，那么我们就直接将这种额外的延伸记录到最后的结果之中
    (3) 对于 Right Extend 实际上处理的整体思想跟left很类似，但有如下的不同
         1: 我们不做类似于第五步的延伸，因为这种延伸在一边使用，就目前的case 而言已经足够。
         2：对于右边的延伸我们要采取左对其的策略

    (4) 将最后的left extend 和 right extend 进行合并
        1: 如果local alignment能够比上，如果并且有一个比对的起点刚好是其自身的Start，那么我们就根据比对的结果进行合并(考虑另一个的起点不是起点或者终点是终点的情况) ，如果仔细想，实际上如果lcoal alignment比对成功，那么结果里面是有一部分的case 不存在重复的seq的。
        2：对于1中 存在重复的 case，我们则采取老办法的合并方式 (16个case, 以及 local alignment的综合运用)













     


       










           	
      


        
          
